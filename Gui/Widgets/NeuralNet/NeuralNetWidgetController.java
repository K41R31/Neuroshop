package Neuroshop.Gui.Widgets.NeuralNet;

public class NeuralNetWidgetController {

    /**     private int numberOfInputs;  TODO: Entsprechend der Anzahl der Input Spalten (InputColumns)
            private int numberOfOutputs; TODO: Entsprechend der Output Spalten (Output Columns)
            private int[] inputColumns; TODO: Wird in einer Tabelle oder so angegeben, man muss festlegen können welche Spalte relevant ist
            private int[] outputColumns; TODO: Das Selbe wie oben

            private DataNormalization dataNormType; TODO: Auswahlmenü für Funktion DataNormalization (Funktionen: MinMax oder ZScore)

            private int dataPercentage; TODO: Schieberegler für Anteil des Datensatzes zum Festlegen wieviel Prozent als Trainings und Testdatensatz verwendet werden (0% - 100%)
            private int[] numberOfHiddenNeurons; TODO: Anzahl der Neuronen im HiddenLayer (0 - offen) ++ Entspricht dann der Anzahl die beim Aufbauen aufs Whiteboard gezogen werden
                                                 TODO: Wird als Array eingegeben {3, 4, 3}. Erster Layer hat 3, zweiter 4 und der dritte wieder 3
            private IActivationFunction[] actFnc; TODO: Hier wird die Aktivierungsfunktion für die jeweiligen HiddenLayer angegeben. Ebenfalls in Reihenfolge wie im obigen Array
            private Linear outputActFnc; TODO: Wird gesondert behandelt, da immer letzter Layer im Netz, bekommt eine eigenen Aktivierungsfunktion. In unserem Fall immer "LINEAR"

            private double minOverallError; TODO: Kleiner Zahlenbereich, sollte immer 0,0... sein, aber nicht zu tief da sich das Netz sonst tot läuft. Am besten so 0,0...
            private double learningRate; TODO: 0.000001 bis maximal 10. Wobei kleinere Zahlenbereiche zwischen 0.0001 bis maximalst 1 sinnvoller sind.
            private double momentumRate; TODO: Können wir auch einfach auf fix 0.7 setzen. Wird benötigt in der Backpropagation. Muss nicht zwingend verändert werden.
            private int iterations; TODO: Von 1 bis offen, wir können nicht wissen wieviele Durchläufe benötigt werden.
     *
     */

}
